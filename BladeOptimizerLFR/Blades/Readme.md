# Blade Parametric Modeling ðŸš€

This folder contains parametric blade models generated by `../BladeGenerator.py`.  
That script is the core tool for creating parametric blade shapes, and all the geometry you see here is defined using flexible formulas and interpolation strategies.  
In this document, Iâ€™ll walk you through the idea behind the parametric design, with formulas included (donâ€™t worry, not too heavy ðŸ’¡), placeholders for figures, and a touch of explanation on why each part is important.  

---

## General Parameterization Idea âœ¨  

We consider a single blade with:
- An angular range **Î˜**  
- A blade height along the **z-axis**, denoted as **H**  
- A normalized span parameter **râ€² âˆˆ [0,1]**, representing blade height (spanwise position).  

For each blade, we sample at **five cylindrical layers** along the span. At each layer, we define shape curves in the Î¸â€“z plane.  

ðŸ‘‰ *Placeholder for figure: Blade geometric definition (similar to Fig. 2.4)*  
![Blade Geometry Placeholder](path/to/your/image.png)

Each layer shares the same leading and trailing edge heights. The angular coordinates of leading/trailing edges may twist along the span if needed.  

---

## Geometry Definition ðŸ“  

We define the **chord line** as the line between the leading edge and trailing edge:  

math''
C(Î¸, râ€²) = zâ‚€ + (Î¸ - Î¸â‚€)/Î˜ â‹… H
''

Then, the blade surface is constructed using the chord line, thickness, and camber (curvature).  
Let:  
- `t(Î¸, râ€²)` = half-thickness  
- `h(Î¸, râ€²)` = camber  

The upper and lower surfaces are:  

math'''
zÂ±(Î¸, râ€²) = -h(Î¸, râ€²) Â± t(Î¸, râ€²)
'''

Both **h** and **t** vary from 0 to a maximum and back to 0 across the chord.  
Thus, we define:  

math'''
h(Î¸, râ€²) = h_max(râ€²) â‹… Î³_râ€²(Î¸)  
t(Î¸, râ€²) = t_max(râ€²) â‹… Ï„_râ€²(Î¸)
'''

with Î³ (relative camber) and Ï„ (relative thickness) satisfying boundary and convexity constraints:  

math'''
Î³_râ€²(Î¸â‚€) = Î³_râ€²(Î¸â‚€+Î˜) = Ï„_râ€²(Î¸â‚€) = Ï„_râ€²(Î¸â‚€+Î˜) = 0  
Î³_râ€²(Î¸), Ï„_râ€²(Î¸) â‰¤ 1
'''

math'''
âˆ‚Â²Î³_râ€²/âˆ‚Î¸Â², âˆ‚Â²Ï„_râ€²/âˆ‚Î¸Â² â‰¤ 0,  Î¸ âˆˆ (Î¸â‚€, Î¸â‚€+Î˜)  
'''

So the full surface becomes:  

math'''
zÂ±(râ€², Î¸) = zâ‚€ + (Î¸ - Î¸â‚€(râ€²))/Î˜ â‹… H - h_max(râ€²)Î³_râ€²(Î¸) Â± t_max(râ€²)Ï„_râ€²(Î¸)
'''

---

## Using Normalized Angle ðŸŒ€  

For convenience, we normalize angle as:  

math'''
Î¸_râ€²â€² = (Î¸ - Î¸â‚€(râ€²)) / Î˜  âˆˆ [0,1]  
Î³_râ€²(Î¸_râ€²â€²), Ï„_râ€²(Î¸_râ€²â€²)
'''

Constraints:  

math'''
Î³_râ€²(0) = Î³_râ€²(1) = Ï„_râ€²(0) = Ï„_râ€²(1) = 0  
sup Î³_râ€² = sup Ï„_râ€² = 1
'''

math'''
âˆ‚Â²Î³_râ€²/âˆ‚Î¸_râ€²â€²Â², âˆ‚Â²Ï„_râ€²/âˆ‚Î¸_râ€²â€²Â² â‰¤ 0, Î¸_râ€²â€² âˆˆ (0,1)
'''

Thus:  

math'''
zÂ±(râ€², Î¸_râ€²â€²) = Î¸â‚€(râ€²) + Î¸_râ€²â€² â‹… H - h_max(râ€²)Î³_râ€²(Î¸_râ€²â€²) Â± t_max(râ€²)Ï„_râ€²(Î¸_râ€²â€²)
'''

---

## Choosing Shape Functions ðŸŽ¨  

Since Î³ and Ï„ are well-behaved functions, we can model them with low-degree polynomials or smooth distributions.  

- **Option 1: Beta-like distribution for camber**  

math'''
Î³_râ€²(Â·) = ( (Â·)^Î±_râ€² â‹… (1-(Â·))^(1-Î±_râ€²) ) / ( Î±_râ€²^Î±_râ€² (1-Î±_râ€²)^(1-Î±_râ€²) )
'''

This allows precise control of maximum camber location by tuning Î±_râ€².  

- **Option 2: Thickness function with plateau**  

math'''
Ï„_râ€²(Â·) = {
   ((1 - cos(Ï€(Â·)/a_râ€²))/2)^Î²_râ€²,        (Â·) âˆˆ [0,a_râ€²]  
   1,                                    (Â·) âˆˆ (a_râ€², b_râ€²)  
   ((1 + cos(Ï€((Â·)-b_râ€²)/(1-b_râ€²)))/2)^Î²_râ€², (Â·) âˆˆ [b_râ€²,1]
}
'''

Parameters a_râ€², b_râ€² define plateau location, Î²_râ€² controls sharpness of tapering.  

---

## Extended Camber Function ðŸŒŠ  

Eq. above sometimes creates excessive curvature at blade tips.  
So we introduce a two-parameter distribution:  

math'''
Î³_râ€²(Â·) = ( (Â·)^(Îºâ‹…Î±) (1-(Â·))^(Îºâ‹…(1-Î±)) ) / ( Î±^Î± (1-Î±)^(1-Î±) )^Îº
'''

Here, Îº smooths the geometry:  
- Îº > 1 â†’ smoother front-end, more streamlined  
- Îº < 1 â†’ sharper curvature (risk of folding)  

Both formulations are kept in the code for flexibility.  

---

## Parameter Summary ðŸ“  

To define one blade, we need:  
- Global parameters: Î˜, H  
- For each of 5 layers:  
  - Î¸â‚€(râ€²), h_max(râ€²), t_max(râ€²)  
  - Î±_râ€² (for camber), a_râ€², b_râ€², Î²_râ€² (for thickness)  

ðŸ‘‰ Total: **37 parameters**.  

Although this sounds like a lot, the design is still feasible because in later optimization we rely on surrogate models (instead of full CFD every time).  

---

## Future Plans ðŸ”®  

- Develop a **UI** for blade parametric modeling  
- Support mainstream blade design tools (e.g. BladeGen-like interfaces)  
- Provide flexible curve models: BÃ©zier curves, splines, etc.  

---

## More Figures ðŸ“Š  

ðŸ‘‰ *Placeholder for figure: Sampling across 5 layers*  
![Layer Sampling Placeholder](path/to/your/image.png)

ðŸ‘‰ *Placeholder for figure: Camber and Thickness distributions*  
![Camber Thickness Placeholder](path/to/your/image.png)

ðŸ‘‰ *Placeholder for figure: Final 3D Blade*  
![3D Blade Placeholder](path/to/your/image.png)

---

Thatâ€™s the gist of how the **parametric blade model** is structured. All formulas are linked, and the workflow is designed to balance flexibility with smoothness. ðŸŽ‰
