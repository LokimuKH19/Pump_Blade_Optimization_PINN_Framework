# Blade Parametric Modeling 🚀

This folder contains parametric blade models generated by `../BladeGenerator.py`.  
That script is the core tool for creating parametric blade shapes, and all the geometry you see here is defined using flexible formulas and interpolation strategies.  
In this document, I’ll walk you through the idea behind the parametric design, with formulas included (don’t worry, not too heavy 💡), placeholders for figures, and a touch of explanation on why each part is important.  

---

## General Parameterization Idea ✨  

We consider a single blade with:
- An angular range **Θ**  
- A blade height along the **z-axis**, denoted as **H**  
- A normalized span parameter **r′ ∈ [0,1]**, representing blade height (spanwise position).  

For each blade, we sample at **five cylindrical layers** along the span. At each layer, we define shape curves in the θ–z plane.  

👉 *Placeholder for figure: Blade geometric definition (similar to Fig. 2.4)*  
![Blade Geometry Placeholder](path/to/your/image.png)

Each layer shares the same leading and trailing edge heights. The angular coordinates of leading/trailing edges may twist along the span if needed.  

---

## Geometry Definition 📐  

We define the **chord line** as the line between the leading edge and trailing edge:  

math''
C(θ, r′) = z₀ + (θ - θ₀)/Θ ⋅ H
''

Then, the blade surface is constructed using the chord line, thickness, and camber (curvature).  
Let:  
- `t(θ, r′)` = half-thickness  
- `h(θ, r′)` = camber  

The upper and lower surfaces are:  

math'''
z±(θ, r′) = -h(θ, r′) ± t(θ, r′)
'''

Both **h** and **t** vary from 0 to a maximum and back to 0 across the chord.  
Thus, we define:  

math'''
h(θ, r′) = h_max(r′) ⋅ γ_r′(θ)  
t(θ, r′) = t_max(r′) ⋅ τ_r′(θ)
'''

with γ (relative camber) and τ (relative thickness) satisfying boundary and convexity constraints:  

math'''
γ_r′(θ₀) = γ_r′(θ₀+Θ) = τ_r′(θ₀) = τ_r′(θ₀+Θ) = 0  
γ_r′(θ), τ_r′(θ) ≤ 1
'''

math'''
∂²γ_r′/∂θ², ∂²τ_r′/∂θ² ≤ 0,  θ ∈ (θ₀, θ₀+Θ)  
'''

So the full surface becomes:  

math'''
z±(r′, θ) = z₀ + (θ - θ₀(r′))/Θ ⋅ H - h_max(r′)γ_r′(θ) ± t_max(r′)τ_r′(θ)
'''

---

## Using Normalized Angle 🌀  

For convenience, we normalize angle as:  

math'''
θ_r′′ = (θ - θ₀(r′)) / Θ  ∈ [0,1]  
γ_r′(θ_r′′), τ_r′(θ_r′′)
'''

Constraints:  

math'''
γ_r′(0) = γ_r′(1) = τ_r′(0) = τ_r′(1) = 0  
sup γ_r′ = sup τ_r′ = 1
'''

math'''
∂²γ_r′/∂θ_r′′², ∂²τ_r′/∂θ_r′′² ≤ 0, θ_r′′ ∈ (0,1)
'''

Thus:  

math'''
z±(r′, θ_r′′) = θ₀(r′) + θ_r′′ ⋅ H - h_max(r′)γ_r′(θ_r′′) ± t_max(r′)τ_r′(θ_r′′)
'''

---

## Choosing Shape Functions 🎨  

Since γ and τ are well-behaved functions, we can model them with low-degree polynomials or smooth distributions.  

- **Option 1: Beta-like distribution for camber**  

math'''
γ_r′(·) = ( (·)^α_r′ ⋅ (1-(·))^(1-α_r′) ) / ( α_r′^α_r′ (1-α_r′)^(1-α_r′) )
'''

This allows precise control of maximum camber location by tuning α_r′.  

- **Option 2: Thickness function with plateau**  

math'''
τ_r′(·) = {
   ((1 - cos(π(·)/a_r′))/2)^β_r′,        (·) ∈ [0,a_r′]  
   1,                                    (·) ∈ (a_r′, b_r′)  
   ((1 + cos(π((·)-b_r′)/(1-b_r′)))/2)^β_r′, (·) ∈ [b_r′,1]
}
'''

Parameters a_r′, b_r′ define plateau location, β_r′ controls sharpness of tapering.  

---

## Extended Camber Function 🌊  

Eq. above sometimes creates excessive curvature at blade tips.  
So we introduce a two-parameter distribution:  

math'''
γ_r′(·) = ( (·)^(κ⋅α) (1-(·))^(κ⋅(1-α)) ) / ( α^α (1-α)^(1-α) )^κ
'''

Here, κ smooths the geometry:  
- κ > 1 → smoother front-end, more streamlined  
- κ < 1 → sharper curvature (risk of folding)  

Both formulations are kept in the code for flexibility.  

---

## Parameter Summary 📝  

To define one blade, we need:  
- Global parameters: Θ, H  
- For each of 5 layers:  
  - θ₀(r′), h_max(r′), t_max(r′)  
  - α_r′ (for camber), a_r′, b_r′, β_r′ (for thickness)  

👉 Total: **37 parameters**.  

Although this sounds like a lot, the design is still feasible because in later optimization we rely on surrogate models (instead of full CFD every time).  

---

## Future Plans 🔮  

- Develop a **UI** for blade parametric modeling  
- Support mainstream blade design tools (e.g. BladeGen-like interfaces)  
- Provide flexible curve models: Bézier curves, splines, etc.  

---

## More Figures 📊  

👉 *Placeholder for figure: Sampling across 5 layers*  
![Layer Sampling Placeholder](path/to/your/image.png)

👉 *Placeholder for figure: Camber and Thickness distributions*  
![Camber Thickness Placeholder](path/to/your/image.png)

👉 *Placeholder for figure: Final 3D Blade*  
![3D Blade Placeholder](path/to/your/image.png)

---

That’s the gist of how the **parametric blade model** is structured. All formulas are linked, and the workflow is designed to balance flexibility with smoothness. 🎉
